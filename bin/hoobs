#!/usr/bin/env node

process.title = "hoobs";

const _ = require("lodash");

const OS = require("os");
const Ora = require("ora");
const File = require("fs-extra");
const Copy = require("recursive-copy");
const Remove = require("rimraf");

const { dirname, join, basename } = require("path");
const { spawn, execSync } = require("child_process");

let password = null;
let debug = false;

const command = process.argv[2];

process.argv.forEach((value, index) => {
    if (value === "-p") {
        password = "#sudo-password#"
    } else if (password === "#sudo-password#") {
        password = value;

        return;
    } else if (value === "-D" || value === "--debug") {
        debug = true;
    }
});

switch ((command || "").toLowerCase()) {
    case "service":
        const sub = process.argv[3];

        switch ((sub || "").toLowerCase()) {
            case "log":
                execSync("journalctl -o cat -n 500 -f -u hoobs", {
                    stdio: "inherit"
                });

                break;

            case "install":
                (async () => {
                    const root = dirname(File.realpathSync(__filename));
                    const enviornment = await (require(join(root, "../scripts/enviornment")))();
                
                    await (require(join(root, "../scripts/migrate")))(enviornment);
                    await (require(join(root, "../scripts/prerequisites")))();
                    await (require(join(root, "../scripts/nginx")))(true);
                    await (require(join(root, "../scripts/systemd")))();
                    await (require(join(root, "../scripts/reboot")))();
                })();

                break;

            case "start":
                if (File.existsSync("/etc/systemd/system/hoobs.service")) {
                    execSync("systemctl start hoobs.service", {
                        stdio: "inherit"
                    });
                }

                break;

            case "stop":
                if (File.existsSync("/etc/systemd/system/hoobs.service")) {
                    execSync("systemctl stop hoobs.service", {
                        stdio: "inherit"
                    });
                }

                break;

            case "restart":
                if (File.existsSync("/etc/systemd/system/hoobs.service")) {
                    execSync("systemctl restart hoobs.service", {
                        stdio: "inherit"
                    });
                }

                break;

            case "enable":
                if (File.existsSync("/etc/systemd/system/hoobs.service")) {
                    execSync("systemctl stop hoobs.service", {
                        stdio: "inherit"
                    });

                    execSync("systemctl disable hoobs.service", {
                        stdio: "inherit"
                    });
                }

                break;

            case "disable":
                if (File.existsSync("/etc/systemd/system/hoobs.service")) {
                    execSync("systemctl enable hoobs.service", {
                        stdio: "inherit"
                    });

                    execSync("systemctl restart homebridge.service", {
                        stdio: "inherit"
                    });
                }

                break;
        }

        break;

    case "upgrade":
        (async () => {
            await (require(join(dirname(File.realpathSync(__filename)), "../scripts/nginx")))(false);
            await (require(join(dirname(File.realpathSync(__filename)), "../scripts/config")))();
        })();

        break;

    case "cockpit":
        new (require(join(dirname(File.realpathSync(__filename)), "../lib/cockpit")))().start(true).then((registration) => {
            console.log("registration code");
            console.log(registration);
        }).catch((error) => {
            console.log(error);
        });

        break;

    case "switch":
        const service = process.argv[3];

        (async () => {
            const root = dirname(File.realpathSync(__filename));

            switch ((service || "").toLowerCase()) {
                case "hoobs":
                    if (File.existsSync("/etc/systemd/system/hoobs.service") && File.existsSync("/etc/systemd/system/homebridge.service")) {
                        execSync("systemctl stop homebridge.service", {
                            stdio: "inherit"
                        });

                        execSync("systemctl disable homebridge.service", {
                            stdio: "inherit"
                        });
                    }

                    if (File.existsSync("/etc/systemd/system/homebridge-config-ui-x.service")) {
                        execSync("systemctl stop homebridge-config-ui-x.service", {
                            stdio: "inherit"
                        });

                        execSync("systemctl disable homebridge-config-ui-x.service", {
                            stdio: "inherit"
                        });
                    }

                    if (File.existsSync("/etc/systemd/system/hoobs.service") && File.existsSync("/etc/systemd/system/homebridge.service")) {
                        execSync("systemctl enable hoobs.service", {
                            stdio: "inherit"
                        });

                        execSync("systemctl restart hoobs.service", {
                            stdio: "inherit"
                        });
                    }

                    break;
                
                case "homebridge":
                    if (File.existsSync("/etc/systemd/system/hoobs.service") && File.existsSync("/etc/systemd/system/homebridge.service")) {
                        execSync("systemctl stop hoobs.service", {
                            stdio: "inherit"
                        });

                        execSync("systemctl disable hoobs.service", {
                            stdio: "inherit"
                        });
                    }

                    if (File.existsSync("/etc/systemd/system/hoobs.service") && File.existsSync("/etc/systemd/system/homebridge.service")) {
                        execSync("systemctl enable homebridge.service", {
                            stdio: "inherit"
                        });

                        execSync("systemctl restart homebridge.service", {
                            stdio: "inherit"
                        });
                    }

                    if (File.existsSync("/etc/systemd/system/homebridge-config-ui-x.service")) {
                        execSync("systemctl enable homebridge-config-ui-x.service", {
                            stdio: "inherit"
                        });

                        execSync("systemctl restart homebridge-config-ui-x.service", {
                            stdio: "inherit"
                        });
                    }

                    break;
                
                case "uninstall":
                    await (require(join(root, "../scripts/uninstall")))((await (require(join(root, "../scripts/enviornment")))()));
                    break;
            }
        })();

        break;

    default:
        const home = OS.userInfo().homedir;
        const root = join(home, ".hoobs");
        const applicaiton = join(dirname(File.realpathSync(__filename)), "../");
        const installed = JSON.parse(File.readFileSync(join(applicaiton, "package.json")));

        let executing = null;
        let throbber = null;

        if (!File.existsSync(root)) {
            File.mkdirSync(root);
        }

        if (File.existsSync(join(root, "package.json"))) {
            try {
                executing = JSON.parse(File.readFileSync(join(root, "package.json")));
            } catch {
                executing = null;
            }
        }

        const sleep = function (time) {
            return new Promise((resolve) => {
                setTimeout(resolve, time);
            })
        };

        const throb = async function (message) {
            if (!debug) {
                message = message || "";

                throbber = Ora(message).start();
                throbber.color = "yellow";

                await sleep(100);
            }
        };

        const update = async function (message, time) {
            if (message && message !== "") {
                if (debug) {
                    console.log(message);
                } else {
                    const data = message.split(":");

                    message = data[0];
                    data.shift();

                    if (data.length > 0) {
                        message += `: ${data.map(v => v.trim().slice(-80)).join(": ")}`;
                    }

                    throbber.text = message;
                    throbber.color = "yellow";

                    await sleep(time);
                }
            }
        };

        const stop = async function (message) {
            if (!debug) {
                await update(message, 10);

                throbber.stop();
            }
        };

        const preparePackage = async function () {
            await throb("Plugins");

            let plugins = [];
            let success = true;

            if (File.existsSync("/var/hoobs/.migration/plugins.json")) {
                await update("Plugins: Migrating existing plugins", 250);

                plugins = JSON.parse(File.readFileSync("/var/hoobs/.migration/plugins.json"));
            }

            if (File.existsSync("/var/hoobs/.migration/dependencies.json")) {
                installed.dependencies = JSON.parse(File.readFileSync("/var/hoobs/.migration/dependencies.json"));
            } else if (executing && executing.dependencies) {
                await update("Plugins: Reading existing plugins", 250);

                let config = null;

                try {
                    config = JSON.parse(File.readFileSync(join(root, "etc", "config.json")));
                } catch {
                    config = null;
                }

                const deps = (config || {}).plugins || [];
                const depKeys = Object.keys(executing.dependencies);

                for (let i = 0; i < deps.length; i++) {
                    await update(`Plugins: ${deps[i]}`, 500);

                    let dep = null;

                    if (executing.dependencies[deps[i]]) {
                        dep = deps[i];
                    } else {
                        dep = (depKeys.filter(d => d.startsWith("@") && d.endsWith(`/${deps[i]}`)) || [null])[0];
                    }

                    if (dep && executing.dependencies[dep]) {
                        installed.dependencies[dep] = executing.dependencies[dep];
                    } else {
                        success = false;
                    }
                }
            }

            if (success) {
                if (installed.devDependencies) {
                    delete installed.devDependencies;
                }

                if (installed.scripts) {
                    delete installed.scripts;
                }

                if (installed.bin) {
                    delete installed.bin;
                }

                await update("Plugins: Writing package file", 250);

                if (File.existsSync(join(root, "package.json"))) {
                    File.unlinkSync(join(root, "package.json"));
                }

                File.appendFileSync(join(root, "package.json"), JSON.stringify(installed, null, 4));

                for (let i = 0; i < plugins.length; i++) {
                    await update(`Plugins: ${plugins[i].name}`, 0);
                    
                    if (!(await npmInstall(plugins[i].name, plugins[i].version))) {
                        success = false;
                    };
                }
            }

            await stop("Plugins");

            return success;
        }

        const setupUserMode = function () {
            return new Promise(async (resolve) => {
                if (File.existsSync("/var/hoobs/.migration/config.json")) {
                    await throb("Configuring");

                    let current = {
                        bridge: {
                            name: "HOOBS",
                            port: 51826,
                            pin: "031-45-154"
                        },
                        description: "",
                        ports: {},
                        plugins: [],
                        interfaces: [],
                        accessories: [],
                        platforms: []
                    };

                    await update("Configuring: Migrating existing configuration", 250);

                    current = _.extend(current, JSON.parse(File.readFileSync(join(applicaiton, "default.json"))));
                    current = _.extend(current, JSON.parse(File.readFileSync("/var/hoobs/.migration/config.json")));

                    if (current.plugins.length === 0 && File.existsSync("/var/hoobs/.migration/plugins.json")) {
                        await update("Configuring: Creating plugin white list", 250);

                        const plugins = JSON.parse(File.readFileSync("/var/hoobs/.migration/plugins.json"));

                        for (let i = 0; i < plugins.length; i++) {
                            if (current.plugins.indexOf(plugins[i].name) === -1) {
                                current.plugins.push(plugins[i].name);
                            }
                        }

                        await update("Configuring: Mapping plugins", 250);

                        const platforms = {};
                        const accessories = {};

                        for (let i = 0; i < (current.platforms || []).length; i++) {
                            if (!platforms[current.platforms[i].platform]) {
                                platforms[current.platforms[i].platform] = [];
                            }

                            platforms[current.platforms[i].platform].push(i);
                        }

                        for (let i = 0; i < (current.accessories || []).length; i++) {
                            if (!accessories[current.accessories[i].accessory]) {
                                accessories[current.accessories[i].accessory] = [];
                            }

                            accessories[current.accessories[i].accessory].push(i);
                        }

                        for (let i = 0; i < plugins.length; i++) {
                            for (let j = 0; j < (plugins[i].details || []).length; j++) {
                                switch (plugins[i].details[j].type) {
                                    case "platform":
                                        for (let k = 0; k < (platforms[plugins[i].details[j].alias] || []).length; k++) {
                                            current.platforms[platforms[plugins[i].details[j].alias][k]].plugin_map = {
                                                plugin_name: plugins[i].name
                                            }
                                        }

                                        break;

                                    case "accessory":
                                        for (let k = 0; k < (accessories[plugins[i].details[j].alias] || []).length; k++) {
                                            current.accessories[accessories[plugins[i].details[j].alias][k]].plugin_map = {
                                                plugin_name: plugins[i].name,
                                                index: 0
                                            }
                                        }

                                        break;
                                }
                            }
                        }
                    }

                    await update("Configuring: Writing configuration", 250);

                    if (File.existsSync(join(root, "etc", "config.json"))) {
                        File.unlinkSync(join(root, "etc", "config.json"));
                    }

                    File.appendFileSync(join(root, "etc", "config.json"), JSON.stringify(current, null, 4));

                    await stop("Configuring");
                }

                await throb("Modules");

                if (File.existsSync(join(root, "dist"))) {
                    Remove.sync(join(root, "dist"));
                }

                if (File.existsSync(join(root, "lib"))) {
                    Remove.sync(join(root, "lib"));
                }

                Copy(join(applicaiton, "node_modules"), join(root, "node_modules"), {
                    overwrite: true,
                    dot: true,
                    junk: false
                }).on(Copy.events.COPY_FILE_START, async (data) => {
                    await update(`Modules: ${basename(data.src)}`, 0);
                }).finally(async () => {
                    if (File.existsSync(join(root, "package-lock.json"))) {
                        File.unlinkSync(join(root, "package-lock.json"));
                    }

                    if (File.existsSync(join(root, "default.json"))) {
                        File.unlinkSync(join(root, "default.json"));
                    }

                    await update("Modules: default.json", 100);

                    File.copySync(join(applicaiton, "default.json"), join(root, "default.json"));

                    await stop("Modules");

                    resolve();
                });
            });
        }

        const checkEnviornment = function () {
            return new Promise(async (resolve) => {
                await throb("Enviornment");

                const queue = [];

                try {
                    File.accessSync(join(home, ".npm"), File.constants.W_OK);

                    await update(`Enviornment: NPM Cache OK`, 100);
                } catch (err) {
                    await update(`Enviornment: NPM Cache is Root Locked`, 100);

                    queue.push(true);

                    let prompts = 0;

                    const proc = spawn("sudo", [
                        "-S",
                        "-k",
                        "-p",
                        "#sudo-hoobs#",
                        "rm",
                        "-fR",
                        join(home, ".npm")
                    ]);

                    proc.stderr.on("data", (data) => {
                        const lines = `${data}`.split(/\r?\n/);

                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();

                            if (line === "#sudo-hoobs#") {
                                if (++prompts > 1) {
                                    proc.stdin.write("\n\n\n\n");
                                } else {
                                    proc.stdin.write(`${password || ""}\n`);
                                }
                            }
                        }
                    });

                    proc.on("close", async () => {
                        await update(`Enviornment: NPM Cache Reset`, 100);

                        queue.pop();

                        if (queue.length === 0) {
                            await stop("Enviornment");

                            resolve();
                        }
                    });
                }

                try {
                    File.accessSync(join(home, ".config"), File.constants.W_OK);

                    await update(`Enviornment: NPM Configuration OK`, 100);
                } catch (err) {
                    await update(`Enviornment: NPM Configuration is Root Locked`, 100);

                    queue.push(true);

                    let prompts = 0;

                    const proc = spawn("sudo", [
                        "-S",
                        "-k",
                        "-p",
                        "#sudo-hoobs#",
                        "rm",
                        "-fR",
                        join(home, ".config")
                    ]);

                    proc.stderr.on("data", (data) => {
                        const lines = `${data}`.split(/\r?\n/);

                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();

                            if (line === "#sudo-hoobs#") {
                                if (++prompts > 1) {
                                    proc.stdin.write("\n\n\n\n");
                                } else {
                                    proc.stdin.write(`${password || ""}\n`);
                                }
                            }
                        }
                    });

                    proc.on("close", async () => {
                        await update(`Enviornment: NPM Configuration Reset`, 100);

                        queue.pop();

                        if (queue.length === 0) {
                            await stop("Enviornment");

                            resolve();
                        }
                    });
                }

                try {
                    File.accessSync(join(home, ".node-gyp"), File.constants.W_OK);

                    await update(`Enviornment: GYP Build Cache OK`, 100);
                } catch (err) {
                    await update(`Enviornment: GYP Build Cache is Root Locked`, 100);

                    queue.push(true);

                    let prompts = 0;

                    const proc = spawn("sudo", [
                        "-S",
                        "-k",
                        "-p",
                        "#sudo-hoobs#",
                        "rm",
                        "-fR",
                        join(home, ".node-gyp")
                    ]);

                    proc.stderr.on("data", (data) => {
                        const lines = `${data}`.split(/\r?\n/);

                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();

                            if (line === "#sudo-hoobs#") {
                                if (++prompts > 1) {
                                    proc.stdin.write("\n\n\n\n");
                                } else {
                                    proc.stdin.write(`${password || ""}\n`);
                                }
                            }
                        }
                    });

                    proc.on("close", async () => {
                        await update(`Enviornment: NPM Configuration Reset`, 100);

                        queue.pop();

                        if (queue.length === 0) {
                            await stop("Enviornment");

                            resolve();
                        }
                    });
                }

                if (queue.length === 0) {
                    await stop("Enviornment");

                    resolve();
                }
            });
        }

        const migrate = async function () {
            await throb("Migrating");

            if (File.existsSync("/var/hoobs/.migration/access.json")) {
                await update("Migrating: access.json", 250);

                if (File.existsSync(join(root, "etc", "access.json"))) {
                    File.unlinkSync(join(root, "etc", "access.json"));
                }

                File.copySync("/var/hoobs/.migration/access.json", join(root, "etc", "access.json"));
            }

            if (File.existsSync("/var/hoobs/.migration/layout.json")) {
                await update("Migrating: layout.json", 250);

                if (File.existsSync(join(root, "etc", "layout.json"))) {
                    File.unlinkSync(join(root, "etc", "layout.json"));
                }

                File.copySync("/var/hoobs/.migration/layout.json", join(root, "etc", "layout.json"));
            }

            if (File.existsSync("/var/hoobs/.migration/accessories")) {
                await update("Migrating: accessories", 250);

                if (File.existsSync(join(root, "etc", "accessories"))) {
                    Remove.sync(join(root, "etc", "accessories"));
                }

                File.copySync("/var/hoobs/.migration/accessories", join(root, "etc", "accessories"));
            }

            if (File.existsSync("/var/hoobs/.migration/persist")) {
                await update("Migrating: persist", 250);

                if (File.existsSync(join(root, "etc", "persist"))) {
                    Remove.sync(join(root, "etc", "persist"));
                }

                File.copySync("/var/hoobs/.migration/persist", join(root, "etc", "persist"));
            }

            if (File.existsSync("/var/hoobs/.migration/unmanaged.json")) {
                const unmanaged = JSON.parse(File.readFileSync("/var/hoobs/.migration/unmanaged.json"));

                for (let i = 0; i < unmanaged.length; i++) {
                    await update(`Migrating: ${unmanaged[i]}`, 250);

                    if (File.existsSync(join(root, "etc", unmanaged[i]))) {
                        File.unlinkSync(join(root, "etc", unmanaged[i]));
                    }

                    File.copySync(join("/var/hoobs/.migration", unmanaged[i]), join(root, "etc", unmanaged[i]));
                }
            }

            await stop("Migrating");
        };

        const npmInstall = function (name, version) {
            return new Promise((resolve) => {
                const proc = spawn("npm", [
                    "install",
                    "--unsafe-perm",
                    `${name}${version && version !== "" ? `@${version}` : ""}`
                ], {
                    cwd: root
                });

                proc.stderr.on("data", async (data) => {
                    data = `${data}`.split("\n");
                    data = data.map(l => l.trim());
                    data = data.join(" - ");

                    await update(`Plugins: ${name} - ${data}`, 0);
                });

                proc.on("close", () => {
                    if (File.existsSync(join(root, "node_modules", name))) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                });
            });
        };

        const clearMigration = function() {
            return new Promise(async (resolve) => {
                await throb("Clear Migration");

                let prompts = 0;

                const proc = spawn("sudo", [
                    "-S",
                    "-k",
                    "-p",
                    "#sudo-hoobs#",
                    "rm",
                    "-fR",
                    "/var/hoobs/.migration"
                ]);

                proc.stderr.on("data", (data) => {
                    const lines = `${data}`.split(/\r?\n/);

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();

                        if (line === "#sudo-hoobs#") {
                            if (++prompts > 1) {
                                proc.stdin.write("\n\n\n\n");
                            } else {
                                proc.stdin.write(`${password || ""}\n`);
                            }
                        }
                    }
                });

                proc.on("close", async () => {
                    await update(`Clear Migration: Migration cleared`, 100);
                    await stop("Clear Migration");

                    resolve();
                });
            });
        };

        checkEnviornment().then(async () => {
            if (!executing || installed.version !== executing.version || !File.existsSync(join(root, "lib")) || !File.existsSync(join(root, "dist"))) {
                let success = true;

                if (File.existsSync("/var/hoobs/.migration")) {
                    await migrate();

                    if (await preparePackage()) {
                        await setupUserMode();
                        await clearMigration();
                    } else {
                        success = false;

                        if (!File.existsSync(join(root, "lib")) || !File.existsSync(join(root, "dist"))) {
                            throw new Error("Plugins failed to migrate");
                        } else {
                            console.log("Plugins failed to migrate");
                            console.log("Loading previous version");
                        }
                    }
                } else {
                    if (await preparePackage()) {
                        await setupUserMode();
                    } else {
                        success = false;

                        if (!File.existsSync(join(root, "lib")) || !File.existsSync(join(root, "dist"))) {
                            throw new Error("There are installed plugins that are not logged");
                        } else {
                            console.log("There are installed plugins that are not logged");
                            console.log("You must edit the package.json file and enter the proper dependencies");
                            console.log("Loading previous version");
                        }
                    }
                }

                if (success) {
                    await throb("Application");

                    Copy(join(applicaiton, "dist"), join(root, "dist"), {
                        overwrite: true,
                        dot: true,
                        junk: false
                    }).on(Copy.events.COPY_FILE_START, async (data) => {
                        await update(`Application: ${basename(data.src)}`, 100);
                    }).finally(() => {
                        Copy(join(applicaiton, "lib"), join(root, "lib"), {
                            overwrite: true,
                            dot: true,
                            junk: false
                        }).on(Copy.events.COPY_FILE_START, async (data) => {
                            await update(`Application: ${basename(data.src)}`, 100);
                        }).finally(async () => {
                            await stop("Application", 10);

                            require(join(root, "lib/cli"))();
                        });
                    });
                } else {
                    require(join(root, "lib/cli"))();
                }
            } else {
                require(join(root, "lib/cli"))();
            }
        });

        break;
}
