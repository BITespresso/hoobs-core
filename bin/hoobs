#!/usr/bin/env node

process.title = "hoobs-core";

const OS = require("os");
const Ora = require("ora");
const File = require("fs-extra");
const Copy = require("recursive-copy");
const Remove = require("rimraf");

const { dirname, join, basename } = require("path");
const { spawn } = require("child_process");

let password = null;
let debug = false;

process.argv.forEach((value, index) => {
    if (value === "-p") {
        password = "#sudo-password#"
    } else if (password === "#sudo-password#") {
        password = value;

        return;
    } else if (value === "-D" || value === "--debug") {
        debug = true;
    }
});

const home = OS.userInfo().homedir;
const root = join(home, ".hoobs");
const applicaiton = join(dirname(File.realpathSync(__filename)), "../");
const installed = JSON.parse(File.readFileSync(join(applicaiton, "package.json")));

let executing = null;
let throbber = null;

if (!File.existsSync(root)){
    File.mkdirSync(root);
}

if (File.existsSync(join(root, "package.json"))) {
    try {
        executing = JSON.parse(File.readFileSync(join(root, "package.json")));
    } catch {
        executing = null;
    }
}

const sleep = function(time) {
    return new Promise((resolve) => {
        setTimeout(resolve, time);
    })
};

const throb = async function(message) {
    if (!debug) {
        message = message || "";

        throbber = Ora(message).start();
        throbber.color = "yellow";           

        await sleep(100);
    }
};

const update = async function(message, time) {
    if (message && message !== "") {
        if (debug) {
            console.log(message);
        } else {
            const data = message.split(":");

            message = data[0];
            data.shift();

            if (data.length > 0) {
                message += `: ${data.map(v => v.trim().slice(-80)).join(": ")}`;
            }

            throbber.text = message;
            throbber.color = "yellow";

            await sleep(time);
        }
    }
};

const stop = async function(message) {
    if (!debug) {
        await update(message, 10);

        throbber.stop();
    }
};

const preparePackage = async function() {
    await throb("Plugins");

    if (executing && executing.dependencies) {
        const dependencies = Object.keys(executing.dependencies);

        for (let i = 0; i < dependencies.length; i++) {
            const name = dependencies[i];
            const dependency = executing.dependencies[dependencies[i]];

            if ((name.startsWith("homebridge-") || (name.startsWith("@hoobs/") && name !== "@hoobs/homebridge")) && !installed.dependencies.hasOwnProperty(name)) {
                await update(`Plugins: ${name}`, 500);

                installed.dependencies[name] = dependency;
            }
        }
    }

    if (installed.devDependencies) {
        delete installed.devDependencies;
    }

    if (installed.scripts) {
        delete installed.scripts;
    }

    if (installed.bin) {
        delete installed.bin;
    }

    if (File.existsSync(join(root, "package.json"))) {
        File.unlinkSync(join(root, "package.json"));
    }

    File.appendFileSync(join(root, "package.json"), JSON.stringify(installed, null, 4));

    await stop("Plugins");
}

const setupUserMode = function() {
    return new Promise(async (resolve) => {
        await throb("Modules");

        if (File.existsSync(join(root, "dist"))) {
            Remove.sync(join(root, "dist"));
        }

        if (File.existsSync(join(root, "lib"))) {
            Remove.sync(join(root, "lib"));
        }

        Copy(join(applicaiton, "node_modules"), join(root, "node_modules"), {
            overwrite: true,
            dot: true,
            junk: false
        }).on(Copy.events.COPY_FILE_START, async (data) => {
            await update(`Modules: ${basename(data.src)}`, 0);
        }).finally(async () => {
            if (File.existsSync(join(root, "package-lock.json"))) {
                File.unlinkSync(join(root, "package-lock.json"));
            }
        
            if (File.existsSync(join(root, "default.json"))) {
                File.unlinkSync(join(root, "default.json"));
            }

            await update("Modules: default.json", 100);

            File.copySync(join(applicaiton, "default.json"), join(root, "default.json"));
        
            await stop("Modules");

            resolve();
        });
    });
}

const checkEnviornment = function () {
    return new Promise(async (resolve) => {
        await throb("Enviornment");

        const queue = [];

        try {
            File.accessSync(join(home, ".npm"), File.constants.W_OK);

            await update(`Enviornment: NPM Cache OK`, 100);
        } catch (err) {
            await update(`Enviornment: NPM Cache is Root Locked`, 100);

            queue.push(true);

            let prompts = 0;

            const proc = spawn("sudo", [
                "-S",
                "-k",
                "-p",
                "#sudo-hoobs#",
                "rm",
                "-fR",
                join(home, ".npm")
            ]);

            proc.stderr.on("data", (data) => {
                const lines = `${data}`.split(/\r?\n/);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (line === "#sudo-hoobs#") {
                        if (++prompts > 1) {
                            proc.stdin.write("\n\n\n\n");
                        } else {
                            proc.stdin.write(`${password || ""}\n`);
                        }
                    }
                }
            });

            proc.on("close", async () => {
                await update(`Enviornment: NPM Cache Reset`, 100);

                queue.pop();

                if (queue.length === 0) {
                    await stop("Enviornment");

                    resolve();
                }
            });
        }

        try {
            File.accessSync(join(home, ".config"), File.constants.W_OK);

            await update(`Enviornment: NPM Configuration OK`, 100);
        } catch (err) {
            await update(`Enviornment: NPM Configuration is Root Locked`, 100);

            queue.push(true);

            let prompts = 0;

            const proc = spawn("sudo", [
                "-S",
                "-k",
                "-p",
                "#sudo-hoobs#",
                "rm",
                "-fR",
                join(home, ".config")
            ]);

            proc.stderr.on("data", (data) => {
                const lines = `${data}`.split(/\r?\n/);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (line === "#sudo-hoobs#") {
                        if (++prompts > 1) {
                            proc.stdin.write("\n\n\n\n");
                        } else {
                            proc.stdin.write(`${password || ""}\n`);
                        }
                    }
                }
            });

            proc.on("close", async () => {
                await update(`Enviornment: NPM Configuration Reset`, 100);

                queue.pop();

                if (queue.length === 0) {
                    await stop("Enviornment");

                    resolve();
                }
            });
        }

        try {
            File.accessSync(join(home, ".node-gyp"), File.constants.W_OK);

            await update(`Enviornment: GYP Build Cache OK`, 100);
        } catch (err) {
            await update(`Enviornment: GYP Build Cache is Root Locked`, 100);

            queue.push(true);

            let prompts = 0;

            const proc = spawn("sudo", [
                "-S",
                "-k",
                "-p",
                "#sudo-hoobs#",
                "rm",
                "-fR",
                join(home, ".node-gyp")
            ]);

            proc.stderr.on("data", (data) => {
                const lines = `${data}`.split(/\r?\n/);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (line === "#sudo-hoobs#") {
                        if (++prompts > 1) {
                            proc.stdin.write("\n\n\n\n");
                        } else {
                            proc.stdin.write(`${password || ""}\n`);
                        }
                    }
                }
            });

            proc.on("close", async () => {
                await update(`Enviornment: NPM Configuration Reset`, 100);

                queue.pop();

                if (queue.length === 0) {
                    await stop("Enviornment");

                    resolve();
                }
            });
        }

        if (queue.length === 0) {
            await stop("Enviornment");

            resolve();
        }
    });
}

checkEnviornment().then(async () => {
    if (!executing || installed.version !== executing.version || !File.existsSync(join(root, "lib")) || !File.existsSync(join(root, "dist"))) {
        await preparePackage();

        setupUserMode().then(async () => {
            await throb("Application");

            Copy(join(applicaiton, "dist"), join(root, "dist"), {
                overwrite: true,
                dot: true,
                junk: false
            }).on(Copy.events.COPY_FILE_START, async (data) => {
                await update(`Application: ${basename(data.src)}`, 100);
            }).finally(() => {
                Copy(join(applicaiton, "lib"), join(root, "lib"), {
                    overwrite: true,
                    dot: true,
                    junk: false
                }).on(Copy.events.COPY_FILE_START, async (data) => {
                    await update(`Application: ${basename(data.src)}`, 100);
                }).finally(async () => {
                    await stop("Application", 10);

                    require(join(root, "lib/cli"))();
                });
            });
        });
    } else {
        require(join(root, "lib/cli"))();
    }
});
